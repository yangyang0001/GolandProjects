------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- 第1章 包、变量和函数 --------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
学习地址: https://tour.go-zh.org/list

注意点: := 短变量声明 不能再函数外使用! 且常量不能使用 := 进行声明!

Printf 常用的替换符:
    %v 即 %value, 表示 value!
    %T 即 %Type , 表示 类型!

Go 语言基本类型:
    string
    bool
    int  int8  int16  int32  int64              // int  系列
    uint uint8 uint16 uint32 uint64 uintptr     // unit 系列
    float32 float64
    byte                    // unit8 别名
    rune                    // int32 别名, 表示 unicode 码点
    complex64 complex128    // 对应数学中的 虚数, 即 实数 + 虚部的方式! 举例: z complex128 = cmplx.Sqrt(-5 + 12i)

    零值:
    string  零值为 ""
    bool    零值为 false
    数值类型 零值为 0

类型转换:
    表达式 T(value) 将值 v 转换为 T 类型!

类型推导:
    var i int = 10
    j := i  // 推导出 j 也是 int 类型!

    i := 10             // int
    j := 3.1415         // float64
    m := 0.867 + 0.5i   // complex128

常量: const a = 100, 常量的类型 要根据结果来定,


------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------- 第2章 流程控制语句 --------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
循环结构:

    注意: go 语言中只有一种 循环结构 for

    for :
        基本结构: 有三部分组成, 这和 java 语言是一样的, 不同的是 go 语言中的 for 没有小括号, 格式如下:

        for 初始化语句; 条件表达式; 后置语句 {
            ...
        }

        基本结构作用:
            1、初始化语句: 循环前只执行一次!　　　    // 可选项
            2、条件表达式: 每次进入循环体都判断!
            3、后置语句:   每次执行完循环体后执行!   // 可选项

    while:
        go 语言中 没有 while 语句, for 即 while 使用格式如下:

        for 条件表达式 {
            ...
        }

    死循环:
        没有条件判断语句 就是 死循环!
        for {
            ...
        }

条件判定结构:
    if:
        go 语言中的 if 和 java 中的 if 基本类似, 不同点: 没有小括号, 且可以在一行中 添加短变量声明, 中间用 分号隔开, 格式如下:

        if 多变量声明; 条件表达式 {
            ...
        }

        举例:
        if value := 10.0; value < 100.0 {
            ...
        }

    switch:
        go 语言中的 switch 和 java 中的不同点: 这里不需要设定 常量, 且不需要 break; 因为 go 语言已经在 每个 case 中后面内置了 break;

        switch 语句的执行顺序为: 从上到下顺序执行, 直到查询到匹配的值!


defer:
    defer 语句, 会将 defer 修饰的函数推迟到 外部函数结束后 再执行! 这句话非常重要, 使用 defer 必须在函数内部, 在函数接收后再执行 defer 后的语句!

    案例: defer 这种有压栈的感觉, 如果多个 defer 语句连续执行, 则最后一个 defer 语句最先执行! 第一个 defer 语句最后执行!

        func defer_statck() {
            fmt.Println("defer_stack method invoke start ...")

            for i := 0; i < 10; i++ {
                defer fmt.Printf("i = %v \n", i)
            }

            fmt.Println("defer_stack method invoke end ...")
        }

    执行结果为:
        defer_stack method invoke start ...
        defer_stack method invoke end ...
        i = 9
        i = 8
        i = 7
        i = 6
        i = 5
        i = 4
        i = 3
        i = 2
        i = 1
        i = 0

------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------- 第3章 指针、结构体、数组、切片和映射 ------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
指针类型:
    go 语言 和 c, c++ 相比, 没有指针运算! go 语言中指针不能声明, 只能使用! 特别注意: 指针 *, 引用 & , 最常用的是引用!

    i, j := 100, 1024
    p := &i     // 拿到 i 的指针!
    q := &j     // 拿到 j 的指针!

    *p = 10     // 通过指针为 i 重新赋值
    *q = 11     // 通过指针为 j 重新赋值

结构体:
    go 语言 中 结构体定义格式如下:
        type 结构体名称 struct {
            ...
        }

    结构体的不同赋值方式:
        type Point struct {
            X int
            Y int
        }

        point1 := Point {1, 3}       // 直接赋值
        point2 := Point {X:1}        // X = 1, Y = 0, Y 被隐式的赋零值!
        point3 := Point {}           // X = 0, Y = 0
        point4 := &Point {1, 3}      // 创建 结构体引用, 这个引用就代表当前 结构体!

数组和切片:

    数组:
        go 语言中 数组定义格式如下:
        []T 表示 T 类型的数组! 数组的大小是固定的;

    切片:
        类似于动态的数组, 数组是固定大小的, 切片类似于 subarray, 或者 java 中的 subList, substring 的感觉!

        使用格式如下:
            subs := array[low : high]       // 本语句表明 使用 array index 的范围为 [low, high) 的左闭右开区间, 包含左边 不包含右边!

        使用案例如下:
            首先定义一个数组:
            base := []int {1, 2, 3, 4, 5, 6}

            根据数组进行切片使用:
            subs := base[1 : 3]             // base index 范围 [1, 3) 因此 subs 为 [2, 3]

    切片 和 数组 特性:
        切片 和 数组 共享同一份数据, 一旦修改二者共有的元素, 二者都会受到影响!

    空切片:
        举例: var s []int, 这种空切片的 容量 和 长度都等于 0! 空切片 为 nil

    使用 make 创建 切片:
        a := make(int[], 5)

    二维数组:
        遍历需要使用到 二维数组!

    添加值:
        使用 append 方法, 使用方式:
        var arr []int
        arr = append(arr, 1, 3, 5); // 可以添加过个值!

range 循环:
    这里 单独拿出来 并不是 只有切片使用, 数组, Map 都会用到这种遍历方式! 返回两个值, 第一个表示: 切片元素的下标, 第二个表示: 切片元素的值!

    for index, value := range arr {

    }

    // 如果不用 index, 或者 value 可以用 _ 代替, 写法如下:
    for _, value := range arr {

    }
    for index, _ := range arr {

    }

    注意在 Map 中的 遍历时, 会返回 key, value 两个值! 使用方式如下:
    for key, value := range map {

    }

映射:
    go 语言中的称 map 为 映射, 其实就是 java 中的 Map<K, V>

函数:
    go 语言中 函数 也可以作为参数和返回值使用! 分别举了两个例子: func 作为参数的例子; func 作为返回值的例子

------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------- 第4章 方法和接口 ----------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
go 语言中的方法参数, 除非使用指针, 其他的都是值传递!

方法:
    struct 添加方法:
        go 语言中, 结构内部是没有方法的, 这和 java 是不一样的, 但是可以在外部为 struct 定义方法! 定义格式如下:

        func (obj T) funcName(方法参数) 返回值 {
            ...
        }

        指针接收者 方法, 在 go 语言中 如果不使用 指针则 方法的参数都是 值传递! 这 和 java 有颠覆性的不同! 指针接收者方法 定义如下:

        func (p *T) funcName(方法参数) 返回值 {
            ...
        }

    指针参数的函数或方法:
        go 语言中, 方法都认为是值传递, 为了更好的操控传入的 struct 类型的值, 这时有了指针参数! 使用格式如下:

        func name(p *T) 返回值 {
            ...
        }

    模拟 java 中的 set method 和  get method:

        上面有了 接收指针的方法, 这里完全可以使用, 这种类型的方法来完成需求!


接口:
    go 语言中接口的定义格式如下:

    type 接口名称 interface {
        方法名称 返回值
    }

    go 语言中的接口类似于 java 中的 抽象类和接口的 综合体;
    表示: 一旦 某个类型或者结构体 具有了当前接口中 定义的所有方法, 那么就隐式的认为 某个类型或结构体实现了 当前接口!

    空接口:
        go 语言中的 空接口, 类似于 java 中的 Object 超级类的感觉, 任何类的父类都是 Object! 空接口定义格式如下:

        type 接口名称 interface {
            // 没有任何方法
        }

        空接口官方定义: 接口体中 不声明任何方法 的接口 称之为 空接口!

        空接口定义的 类型 可以赋 任何类型的值, 因为 任何类型都可以不实现任何方法!

        switch case 来实现 空接口类型的判定, 这里有个语法 只能在 switch 中使用, 案例如下:
        func do(i interface {}) {
            switch typeI := i.(type) {      // 这里的 i.(type) 只能在 switch 中使用, 否则编译报错!
            case int: ...
            case string: ...
            default: ....
            }
        }

Stringer 和 error 内置接口!
    type Stringer() interface {
        String() string
    }

    type error interface {
        Error() string
    }


------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------- 第5章 Reader 和 Image ----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
接下来了解两个 比较常用的 接口!
Reader:
    本案例中只使用了 strings.NewReader("") 的案例! 在其他书籍中, 在补充这块, 这块将的知识还是不够系统!

Image:
    如果你是自己看书, 看到此处, 仅凭目前的基础知识, 想了解 "image" "image/color" 包 还是有不小难度的! 这块需要 再 往后看书籍 去补充 基础规则知识!


------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------- 第6章 并发 ------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
goroutine:
    概念:
        是由 Go 运行时管理的轻量级线程!
        调用方法时 使用 关键字 go, 举例: go SayHello("...")

信道 channel
    基础概念:
        关键字 chan, 使用 符号 <- 箭头表示数据的流向! 取值则符合 stack 的特性, 属于先进后出 或 后进先出的 取值特性!
        必须配合 go 语法使用, 否则报错!

    range 和 close:
        信道 不同于 文件, 一般是不需要关闭的!
        数据接收方是不能关闭信道的, 只有数据发送方才能关闭信道;

select 语句:
    select 可以使不同的 channel 进行切换!

排他锁/互斥锁: sync.Mutex, 这和 java 使用的 zookeeper 中的 分布式锁中的 InterProcessMutex 都是排他锁!

Web 编程: Web 爬虫 练习!











