------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------- 第 1 章: GO 环境配置 -------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
查看 当前系统的是 多少位的, 执行命令 uname -m

    本人 MacOS 系统, 使用如下:

    yangjianwei@yangjianweideMacBook-Pro ~ % uname -a
    Darwin ip-192-168-43-34.us-west-2.compute.internal 20.6.0 Darwin Kernel Version 20.6.0: Wed Jun 23 00:26:31 PDT 2021; root:xnu-7195.141.2~5/RELEASE_X86_64 x86_64

    yangjianwei@yangjianweideMacBook-Pro ~ % uname -m
    x86_64

开发工具
    IDEA + GO插件!

安装 GO
    本人配置如下:
    ############################################  go环境 ########################################
    export GOROOT=/usr/local/go
    export GOPATH=/Users/yangjianwei/GolandProjects
    export PATH=$PATH:$GOROOT/bin

GOROOT 表示 Go 在你的电脑上的安装位置, 它的值一般都是 $HOME/go, 当然 你也可以安装在别的地方       // 这个属性要配置, 非常重要!

GOPATH 下必须包含 src, pkg, bin 三个文件夹, 类似于 java 中的 src main java 的默认规定一样, github 上也没有给出太多的解释, 就说是规定!
    src 源文件存放地址!
    pkg 引入的包文件存放地址!
    bin 可执行文件存放地址!

GOMODULE 常用命令
    go mod init         # 初始化 go.mod
    go mod tidy         # 更新依赖文件
    go mod download     # 下载依赖文件
    go mod vendor       # 将依赖转移至本地的 vendor 文件
    go mod edit         # 手动修改依赖文件
    go mod graph        # 打印依赖图
    go mod verify       # 校验依赖

本书不适合初学者! 初学者 先看 前面的书籍!

------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------- 第 2 章: Go语言基础 --------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
iota
    这是一个特殊常量, 这个符号 遇到 const 定义时, 就是一个常量 且值 = 0!
    特性: iota 每次遇到 const 都重置为0, 同一行中的 iota 值都一致的, 下一行的 iota 值自动 +1;

init 函数
    所有参与执行的 init 函数 优先级 都 高于 main() 可以参考 001_go语言_init函数的执行过程.png!


struct 结构体
    定义格式如下:
    type 结构体名称 struct {
        ...
    }

    注意点: 注意结构体名称 和 内部属性 首字母的大小写问题!

struct 结构体中的 匿名字段问题!

struct 面向对象
    主要是 实现类似 java class 的方法, 继承 等功能!

interface
    接口的定义:
        type 接口名称 interface {
            方法名称([方法参数列表]) [返回值列表]
        }

    接口的实现:
        对比 java 的定义, 是实现所有 接口中的方法, 才能称之为 实现了接口, 这一点是一致的! 不同的是这里没有 implements 关键字

        为了标识 实现了哪个接口, 往往在 interface 中多写一个方法, 方法名称往往称之为 Implement接口名称()!

    接口的扩展:
        如果 一个 结构体A 包含了一个 结构体B, 结构体B 实现了 接口I, 那么 这个 接口I 的变量 也可以接受 结构体A 的实例!

    接口的歧义:
        因为上面的扩展, 带来的疑惑: 结构体A 只是继承了 结构体B的属性和方法, 严格来说 接口I 和 结构体A没有任何关系! 但是这里直接继承了这种特性!

    空接口:
        使用 空接口 来判定任何东西的 类型!

    接口合并:
        接口A, 接口B, 如果想使用 接口A和接口B中的合并成为一个新的接口C, 只需要使用如下的方式构造一个新的接口就可以了!

        type A interface{
            ...
        }

        type B interface {
            ...
        }

        type C interface {
            A
            B
        }

并发
    协程的概念: 代码中并发的代码统称为 协程! 协程之间沟通 不是通过传统变量, 而是通过 信道或者通道 channel!

    使用协程 的关键字: go

channel
    通道的定义: channel := make(chan int)    cap = 0

buffered channel
    定义方式: channel := make(chan int, 5)  cap = 5

select 处理不同的 channel:

    常用处理方案如下: 往往用死循环去包裹, 每次校验是否有 非阻塞 channel!

    for {
        select {
        case val0 := <-channel0
            ....
        case val1 := <-channel1
            ....
        case val2 := <-channel2
            ....
        default:
            ....
        }
    }

runtime 包中有几个处理 goroutine 的函数:
    Goexit:         退出当前执行的goroutine, 但是defer函数还会继续调用
    Gosched:        让出当前goroutine的执行权限, 调度器安排其他等待的任务运行, 并在下次某个时候从该位置恢复执行
    NumCPU:         返回 CPU 核数量
    NumGoroutine:   返回正在执行和排队的任务总数
    GOMAXPROCS:     用来设置可以并行计算的CPU核数的最大值, 并返回之前的值

------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- 第 3 章: Web基础 ----------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
web 服务:
   基于 http 协议的一种服务!

搭建一个 web 服务:

    参考 001_http_web, 其访问方式为: http://localhost:9090/?url_long=111&url_long=222

    这种访问方式, 可以使用 ? 和 & 拼接符传递参数! 也可以使用路径参数!
    request.Form 是一个 key 为 string 类型, val 为 []string 的 Map, 即为 map[string] []string!

理解 http 服务的工作过程:
    1、整个工作 过程参考 001_web服务器_http请求响应工作流程.png

    2、http web 服务是建立在 tcp 服务基础上的

总结:
    本章不能叫 Web基础, 应该叫 网络基础, 如果想看网络知识的 可以参考 java_computer_network 工程!

------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------- 第 4 章: 表单 ------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
反思:
    java web 已经非常 完善了! 那么 go 语言产生的时间 比 java 短, 可否借鉴一下 java 处理 web 方面的思想呢? 甚至翻译 java 为 go 呢?

案例:
    首先 搭建一个 go web 服务

    使用 template.ParseFiles 来处理返回的 html 文本!

注意:
    request.Form 是一个 map[string][]string 类型, key = string, value = []string 类型! 且内部提供了 Set, Get, Add, Del 方法!

验证表单的输入:
    验证方式:
        前端校验 和 后端校验!

    处理手段:
        有了 template.ParseFiles() 方法来处理 html 文本文件, 这时前端是固定的, 没有什么硬性对 前端表单进行校验, 纵然做了, 后端也会再次处理!

    正则表达校验:

        数字校验:
        if m, _ := regexp.MatchString("^[0-9]+$", request.FormValue("age")); !m {
        	return false
        }

        中文校验:
        if m, _ := regexp.MatchString("^\\p{Han}+$", request.FormValue("realname")); !m {
        	return false
        }

        英文校验:
        if m, _ := regexp.MatchString("^[a-zA-Z]+$", request.FormValue("engname")); !m {
        	return false
        }

        邮件校验:
        if m, _ := regexp.MatchString(`^([\w\.\_]{2,10})@(\w{1,})\.([a-z]{2,4})$`, request.FormValue("email")); !m {
        	return false
        }

        手机校验:
        if m, _ := regexp.MatchString(`^(1[3|4|5|8][0-9]\d{4,8})$`, request.FormValue("mobile")); !m {
        	return false
        }

        身份证校验:
        //验证15位身份证，15位的是全部数字
        if m, _ := regexp.MatchString(`^(\d{15})$`, request.FormValue("usercard")); !m {
            return false
        }

        //验证18位身份证，18位前17位为数字，最后一位是校验位，可能为数字或字符X。
        if m, _ := regexp.MatchString(`^(\d{17})([0-9]|X)$`, request.FormValue("usercard")); !m {
            return false
        }

预防 JS 作为参数传递:
    // 转义输出到 client 端!
    template.HTMLEscape(response, []byte(request.FormValue("username")))

    // 非转义输出到 客户端, 如果 username 为 <script>alert()</script>, 则弹窗!
    //io.WriteString(response, request.FormValue("username"))


    // 下面的代码使用了转义 在服务端输出:
    fmt.Printf("key = %v, value = %v \n", key, template.HTMLEscapeString(request.FormValue(key)))

防止多次递交表单
    采用解决方案为
        前端使用:
            <form>
                <input type="hidden" name="token" value="{{.}}"/>
            </form>

        后端使用:
            if request.Method == http.MethodGet {
                // TODO: 生成 token
                hash := crypto.MD5.New()
                hash.Write([]byte(strconv.Itoa(time.Now().Nanosecond())))
                token := fmt.Sprintf("%x", hash.Sum(nil))

                // 将 token 写入表单中!
                temp, err := template.ParseFiles(loginFilePath)
                if err != nil {
                    log.Fatal(err)
                }
                //  TODO: 写出 token
                temp.Execute(response, token)
            } else {
                //CheckForm(request)
                //FormMethd(request)

                // TODO: 处理 token
                token := request.FormValue("token")
                if token == "" {
                    // 非法 token
                    fmt.Println("token is not legitimate!")
                    return
                } else {
                    // 再次验证 token 是否合法 .....

                    // 继续进行下面的代码
                    PrintForm(request)

                    // 转义输出到 client 端!
                    template.HTMLEscape(response, []byte(request.FormValue("username")))

                    // 非转义输出到 客户端, 如果 username 为 <script>alert()</script>, 则弹窗!
                    //io.WriteString(response, request.FormValue("username"))
                }

            }


处理文件上传
    使用 前端页面 上传文件


    使用 代码 模拟客户端 上传文件











------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------- 第 5 章: 访问数据库 --------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------














------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------- 第 6 章: session和数据存储 -----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------














------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------- 第 7 章: 文本文件处理 --------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------














------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- 第 8 章: Web服务 ----------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------














------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- 第 9 章: 安全与加密 --------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------














------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- 第 10 章: 国际化和本地化 ---------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------














------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- 第 11 章: 错误处理, 调试和测试 ----------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------














------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- 第 12 章: 部署与维护 -------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------














------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- 第 13 章: 如何设计一个Web框架 -----------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------














------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------- 第 14 章: 扩展Web框架 -----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------















































































































































